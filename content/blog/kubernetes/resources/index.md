---
title: "Kubernetes resources"
date: 2019-06-04T21:55:06+01:00
draft: false
hideLastModified: true
summaryImage: "images/k8s.png"
keepImageRatio: true
tags: ["kubernetes", "resources"]
summary: "Short overview of Kubernetes resources"
---
## Resources Configuration
All Kubernetes resources have the same structure. The type of an object is defined by its apiVersion and its kind. Each resource is described through a yaml configuration file. Each configuration file is composed by three parts 1) metadata, 2) specification, 3) status.
### 1.Metadata
This part is used to declare additional information about the resource, like its name, a label, etc. 
### 2.Specification
The specification represents the expected status that the resource will have. Notice that the specification fields are specifically related to the kind of resource we are specifying.
### 3.Status
The status part is automatically generated by Kubernetes. It is crucial for the auto healing feature of Kubernetes, in order to check in every moment if the current status matches the desired status. The information about the status of the resource is given by the etcd component, that will be later described.

## Resources
We will now see all the type of resource kind that is possible to define.
### Kubernetes pods
It is the smallest unit of Kubernetes, and it is basically an abstraction of a container, i.e. usually each pod is associated with a running container. Each POD has its own IP address; therefore, each pod can communicate each other using this IP address. POD are ephemeral, therefore they can easily fail. Each time a pod fails, a new IP address is reassigned to it. If we were using IP address to reference application running in pods, this would be really inconvenient, because the IP changes each time the pod fails. For this reason, services exist. Having more than one container per pod can happen, for instance, if you have a web server and a software which handles logs messages. In this case is convenient to put the two services in the same pod. When this happens, containers in the same pod are called sidecars.

***Init containers***
Another example in which two containers are deployed in the same pod, are init containers. They are used to prepare the environment for the actual container that will be later executed. So an init container is deployed first, executed, and when it terminates the “real” container starts.

***Privileged pods***
Privileged pods are pods with special permissions, which are useful for instance when is required that the pod update the configuration of the bare OS.

### Kubernetes nodes
A node is a simple server (physical or virtual machine). In each node you can have a maximum of N pods (usually around 250 pods).
### Kubernetes cluster
A cluster is the set of all resources coordinated by a single K8s instance. In a cluster you can have a maximum of M clusters (usually around 5000 nodes).
### Kubernetes services
A service is an abstraction having a permanent IP address, and it is associated to a given pod. Lifecycles of pods and services are not connected, so when a pod dies, the service will continue living with its permanent IP. There are two types of services:
- External service: are services that can expose a pod to internet
- Internal service: are services which are used only for inter-pod communication, and do not expose the pod to internet. This is useful for databases.

There are 4 types of services.

***ClusterIP*** 
Exposes the Service on a cluster internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default Service Type.

***NodePort***
Exposes the Service on each Node’s IP at a static port (the NodePort). A ClusterIP Service, to which the NodePort Service routes, is automatically created. You’ll be able to contact the NodePort Service, from outside the cluster, by requesting <\NodeIP\>:<\NodePort\>.

***LoadBalancer***
Exposes the Service externally using a cloud provider’s load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, are automatically created.

***Headless service***
It is appropriate when the service does not need load balancing and a single Service IP. 

### Kubernetes ingress
Ingress allows to expose pods with a domain name and a secure protocol (https). When requests from the external world arrives, they get to the ingress which is in charge of forwarding them to the right pod.
### Kubernetes ConfigMap
When some small changes have to be done, like changing the database URL, is very inconvenient to build up again the whole DB container, then pushing it to the container repository with a new tag and restart another pod pulling from the repository. For this reasons ConfigMap exist, which allows you to specify an external configuration for your application, so that it can be changed and the pod will fetch information from there. Within the ConfigMap, it is possible to specify, for instance, the database url, the database user and password.
### Kubernetes Secret
Storing information like user and password of a database in ConfigMap, is not very secure. For this reason, secrets exist. Secret component is just like ConfigMap, but allows to store secret content in base64 encoded. Just like ConfigMap, Secret is connected to the Pod, so that the pod can read data from the Secret. 
### Kubernetes Volumes
This component is needed when we need some data to be persistent even when the pod fails. Volumes are storages that can be whether internal, i.e. within the cluster, or remote, i.e. outside the K8s cluster. Notice that K8s explicitly does not manage any data persistence, therefore the volume should be thought as an “hard drive” that is plugged into the K8s storage, and you are responsible for data backup and management, not K8s.
### Deployment
If a given pod is failing, the corresponding application will be unavailable until the pod is restarted. For this reasons, deployment components are created, which are blueprints for a given application Pod. Actually, we do not deploy pods but deployments, which allows you to specify the number of replicas of the application that must be alive, in order to be fault resilient. These replicas are connected to a load balancer, which redirects properly the requests to them.
### Kubernetes Stateful Set
This component is meant for database application running in a pod, which also need to be replicated. However, for database replicas we do not create deployments, since we need data consistency, when multiple pods are writing / reading from the database replicas. For this reason, another component called stateful set is defined in K8s, which automatically manages database replicas. Stateful set take care of database scaling making sure that writes and reads are synchronized and no data inconsistency is verified.
Notice that working with stateful set can be very tedious and difficult, unlike deployments. That’s why is usually a good practice hosting databases outside the K8s cluster. Within the cluster, just stateless applications are deployed, which can be easily scaled.
